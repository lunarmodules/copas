<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Copas - Coroutine Oriented Portable Asynchronous Services for Lua</title>
    <link rel="stylesheet" href="doc.css" type="text/css"/>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"><a href="http://www.keplerproject.org">
		<img alt="Copas logo" src="copas.png"/>
	</a></div>
	<div id="product_name"><big><strong>Copas</strong></big></div>
	<div id="product_description">Coroutine Oriented Portable Asynchronous Services for Lua</div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">
<h1>Copas</h1>
<ul>
    <li><a href="index.html">Home</a>
        <ul>
            <li><a href="index.html#status">Status</a></li>
            <li><a href="index.html#download">Download</a></li>
            <li><a href="index.html#dependencies">Dependencies</a></li>
            <li><a href="index.html#history">History</a></li>
            <li><a href="index.html#credits">Credits</a></li>
        </ul>
    </li>
    <li><a href="manual.html">Manual</a>
    </li>
    <li><strong>Reference</strong></li>
    <li><a href="http://github.com/lunarmodules/copas/">Project</a>
        <ul>
            <li><a href="http://github.com/lunarmodules/copas/issues">Bug Tracker</a></li>
        </ul>
    </li>
    <li><a href="license.html">License</a></li>
</ul>
</div> <!-- id="navigation" -->

<div id="content">
<h2>Reference</h2>

<p>
<strong>NOTE:</strong> Some functions require DNS lookups, which is handled internally
by LuaSocket. This is being done in a <strong>blocking</strong> manner. Hence every function
that accepts a hostname as an argument (e.g. <code>tcp:connect()</code>,
<code>udp:sendto()</code>, etc.) is potentially blocking on the DNS resolving part.
So either provide IP addresses (assuming the underlying OS will detect those and resolve
locally, non-blocking) or accept that the lookup might block.
</p>

<h3>Getting started examples</h3>

<p>Example for a server handling incoming connections:</p>
<pre class="example">
local copas = require("copas")
local socket = require("socket")

local address = "*"
local port = 20000
local ssl_params = {
    wrap = {
        mode = "server",
        protocol = "any",  -- not really secure...
    },
}

local server_socket = assert(socket.bind(address, port))

local function connection_handler(skt)
    local data, err = skt:receive()

    -- do something

end

copas.addserver(server_socket, copas.handler(connection_handler, ssl_params))

copas.loop()
</pre>


<p>Example for a client making a connection to a remote server:</p>
<pre class="example">
local copas = require("copas")
local socket = require("socket")

copas.addthread(function()
    local port = 20000
    local host = "somehost.com"
    local ssl_params = {
        wrap = {
            mode = "client",
            protocol = "any",  -- not really secure...
        },
    }

    local sock = copas.wrap(socket.tcp(), ssl_params)
    assert(sock:connect(host, port))

    local data, err = sock:receive("*l")

    -- do something

end)

copas.loop()
</pre>


<h3>Copas dispatcher main functions</h3>

<p>The group of functions is relative to the use of the dispatcher itself and
are used to register servers and to execute the main loop of Copas:</p>

<dl class="reference">
    <dt><strong><code>copas.addserver(server, handler[, timeout])</code></strong></dt>
    <dd>Adds a new <code>server</code> and its <code>handler</code> to the dispatcher
        using an optional <code>timeout</code>.<br />
        <code>server</code> is a LuaSocket server socket created using
        <code>socket.bind()</code>.<br />
        <code>handler</code> is a function that receives a LuaSocket client socket
        and handles the communication with that client.<br />
        <code>timeout</code> is the timeout in seconds. Upon accepting connections,
        the timeout will be inherited by TCP client sockets (only applies to TCP).<br />
        The handler will be executed in parallel with other threads and the
        registered handlers as long as it uses the Copas socket functions.
    </dd>

    <dt><strong><code>coro = copas.addthread(func [, ...])</code></strong></dt>
    <dd>Adds a function as a new coroutine/thread to the dispatcher. The optional
        parameters will be passed to the function <code>func</code>.<br />
        The thread will be executed in parallel with other threads and the
        registered handlers as long as it uses the Copas socket/sleep functions.
        It returns the created coroutine.
    </dd>

    <dt><strong><code>copas.autoclose</code></strong></dt>
    <dd>Constant that controls whether sockets are automatically closed.<br />
        When a TCP handler function completes and terminates, then the client
        socket will be automatically closed when <code>copas.autoclose</code> is
        truthy.
    </dd>

    <dt><strong><code>copas.finished()</code></strong></dt>
    <dd>Checks whether anything remains to be done.<br />
        Returns <code>false</code> when the socket lists for reading and writing
        are empty and there is not another (sleeping) task to execute.</br>
        <strong>NOTE:</strong> when tasks or sockets have been scheduled/setup this
        function will return <code>true</code> even if the loop has not yet started.
        See also <code>copas.running</code>.
    </dd>

    <dt><strong><code>func = copas.handler(connhandler [, sslparams])</code></strong></dt>
        <dd>Wraps the <code>connhandler</code> function. Returns a new function that
        wraps the client socket, and (if <code>sslparams</code> is provided) performs
        the ssl handshake, before calling <code>connhandler</code>.
        <br/>See <code>sslparams</code> definition below.
    </dd>

    <dt><strong><code>copas.loop([init_func, ][timeout])</code></strong></dt>
    <dd>Starts the Copas loop accepting client connections for the
        registered servers and handling those connections with the corresponding
        handlers. Every time a server accepts a connection, Copas calls the
        associated handler passing the client socket returned by
        <code>socket.accept()</code>. The <code>init_func</code> function is an
        optional initialization function that runs as a Copas thread.
        The <code>timeout</code> parameter is optional,
        and is passed to the <code>copas.step()</code> function.
        The loop returns when <code>copas.finished() == true</code>.
    </dd>

    <dt><strong><code>copas.removeserver(skt [, keep_open])</code></strong></dt>
    <dd>Removes a server socket from the Copas scheduler.
        By default, the socket will be closed to allow the socket to be reused right away after
        removing the server. If <code>keep_open</code> is <code>true</code>, the socket
        is removed from the scheduler but it is not closed.
    </dd>

    <dt><strong><code>copas.removethread(coroutine)</code></strong></dt>
    <dd>Removes a coroutine added to the Copas scheduler.
        Takes a <code>coroutine</code> created by <code>copas.addthread()</code> and removes
        it from the dispatcher the next time it tries to resume. If <code>coroutine</code> isn't
        registered, it does nothing.
    </dd>

    <dt><strong><code>copas.running</code></strong></dt>
    <dd>A flag set to <code>true</code> when <code>copas.loop()</code> starts, and
        reset to <code>false</code> when the loop exits. See also
        <code>copas.finished()</code>.
    </dd>

    <dt><strong><code>copas.setErrorHandler(func, [default])</code></strong></dt>
    <dd>Sets the error handling function for the current thread. If <code>default</code>
        is truthy, then the handler will become the new default, used for all threads
        that do not have their own set.
        Any errors will be forwarded to this handler, which will receive the
        error, coroutine, and socket as arguments. See the Copas source code
        on how to deal with the arguments when implementing your own.
    </dd>

    <dt><strong><code>copas.wrap(skt [, sslparams] )</code></strong></dt>
    <dd>Wraps a LuaSocket socket and returns a Copas socket that implements LuaSocket's API
        but use Copas' methods like <code>copas.send()</code> and <code>copas.receive()</code>
        automatically. If the <code>sslparams</code> is provided, then a call to the wrapped
        <code>skt:connect()</code> method will automatically include the handshake (and in that
        case <code>connect()</code> might throw an error instead of returning nil+error, see
        <code>copas.dohandshake()</code>).
        <br/>See <code>sslparams</code> definition below.
    </dd>

    <dt><strong><code>sslparams</code></strong></dt>
    <dd>This is the data-structure that is passed to the <code>copas.handler</code>, and
        <code>copas.wrap</code> functions. Passing the structure will allow Copas to take
        care of the entire TLS handshake process.
        </br>The structure is set up to mimic the LuaSec functions for the handshake.
        <pre class="example">
{
  wrap = table | context,    -- parameter to LuaSec 'wrap()'
  sni = {                    -- parameters to LuaSec 'sni()'
    names = string | table   --   1st parameter
    strict = bool            --   2nd parameter
  }
}
        </pre>
    </dd>

</dl>

<h3>Non-blocking data exchange and timer/sleep functions</h3>

<p>These are used by the handler functions to exchange data with
the clients, and by threads registered with <code>addthread</code> to
exchange data with other services.</p>

<dl class="reference">
    <dt><strong><code>copas.sleep([sleeptime])</code></strong></dt>
    <dd>Pauses the current co-routine. Parameter <code>sleeptime</code> (in seconds) is optional
    and defaults to 0. If <code>sleeptime &lt 0</code>
    then it will sleep until explicitly woken by a call to <code>copas.wakeup()</code>.
    </dd>

    <dt><strong><code>copas.wakeup(co)</code></strong></dt>
    <dd><code>co</code> is the coroutine to wakeup, see <code>copas.sleep()</code>.
    </dd>

    <dt><strong><code>sock:close(...)</code></strong></dt>
    <dd>Equivalent to the LuaSocket method (after <code>copas.wrap</code>).
    </dd>

    <dt><strong><code>sock:connect(...)</code></strong></dt>
    <dd>Non-blocking equivalent to the LuaSocket method (after <code>copas.wrap</code>).
    <br/>If <code>sslparams</code> was provided when wrapping the socket, the <code>connect</code>
    method will also perform the full TLS handshake. So after <code>connect</code> returns
    the connection will be secured.
    </dd>

    <dt><strong><code>sock:dohandshake(...)</code></strong></dt>
    <dd>Non-blocking quivalent to the LuaSocket method (after <code>copas.wrap</code>).  Instead of using
    this method, it is preferred to pass the <code>sslparams</code> to the functions
    <code>copas.handler</code> (for incoming connections) and <code>copas.wrap</code> (for
    outgoing connections), which then ensures that the connection will automatically be
    secured when started.
    </dd>

    <dt><strong><code>sock:receive(...)</code></strong></dt>
    <dd>Non-blocking equivalent to the LuaSocket method (after <code>copas.wrap</code>).
    </dd>

    <dt><strong><code>sock:send(...)</code></strong></dt>
    <dd>Non-blocking equivalent to the LuaSocket method (after <code>copas.wrap</code>).
    </dd>

    <dt><strong><code>sock:settimeout([timeout])</code></strong></dt>
    <dd>Sets the timeouts (in seconds) for a socket (after <code>copas.wrap</code>).
    The default is to not have a timeout and wait indefinitely. This method is compatible
    with LuaSocket, but sets all three timeouts to the same value.<br/>
    <strong>Important:</strong> this behaviour is the same as LuaSocket, but different from
    <code>sock:settimeouts</code>, where <code>nil</code> means 'do not change' the timeout.<br/>
    If a timeout is hit, the operation will return <code>nil + "timeout"</code>.
    </dd>

    <dt><strong><code>sock:settimeouts([connect], [send], [receive])</code></strong></dt>
    <dd>Sets the timeouts (in seconds) for a socket (after <code>copas.wrap</code>).
    The default is to not have a timeout and wait indefinitely.<br/>
    <strong>Important:</strong> this behaviour is different from
    <code>sock:settimeout</code>, where <code>nil</code> means 'wait indefinitely'.<br/>
    If a timeout is hit, the operation will return <code>nil + "timeout"</code>.
    </dd>

    <dt><strong><code>sock:sni(...)</code></strong></dt>
    <dd>Equivalent to the LuaSec method (after <code>copas.wrap</code>). Instead of using
    this method, it is preferred to pass the <code>sslparams</code> to the functions
    <code>copas.handler</code> (for incoming connections) and <code>copas.wrap</code> (for
    outgoing connections), which then ensures that the connection will automatically be
    secured when started.
    </dd>

    <dt><strong><code>lock:destroy()</code></strong></dt>
    <dd>Will destroy the lock and release all waiting threads. The result for those
    threads will be <code>nil + "destroyed" + wait_time</code>, any new call on any
    method will return <code>nil + "destroyed"</code> from here on.
    </dd>

    <dt><strong><code>lock:get([timeout])</code></strong></dt>
    <dd>Will try and acquire the lock. The optional <code>timeout</code> can be
    used to override the timeout value set when the lock was created.</br>
    If the the lock is not available, the coroutine will yield until either the
    lock becomes available, or it times out. The one exception is when
    <code>timeout</code> is 0, then it will immediately return without yielding.</br>
    Upon success, it will return the <code>wait-time</code> in seconds. Upon failure it will
    return <code>nil + error + wait-time</code>. Upon a timeout the error value will
    be "timeout".
    </dd>

    <dt><strong><code>lock.new([timeout], [not_reentrant])</code></strong></dt>
    <dd>Creates and returns a new lock. The <code>timeout</code> specifies the
    default timeout for the lock in
    seconds, and defaults to 10. By default the lock is re-entrant,
    except if <code>not_reentrant</code> is set to a truthy value.
    </dd>

    <dt><strong><code>lock:release()</code></strong></dt>
    <dd>Releases the currently held lock. Returns <code>true</code> or <code>nil + error</code>.
    </dd>

    <dt><strong><code>semaphore:destroy()</code></strong></dt>
    <dd>Will destroy the sempahore and release all waiting threads. The result for those
    threads will be <code>nil + "destroyed"</code>, any new call on any
    method will return <code>nil + "destroyed"</code> from here on.
    </dd>

    <dt><strong><code>semaphore:get_count()</code></strong></dt>
    <dd>Returns the number of resources currently available in the semaphore.
    </dd>

    <dt><strong><code>semaphore:get_wait()</code></strong></dt>
    <dd>Returns the total number of resources requested by all currently waiting threads minus
    the available resources. Such that <code>sempahore:give(semaphore:get_wait())</code> will
    release all waiting threads and leave the semaphore with 0 resources. If there are no waiting threads
    then the result will be 0, and the number of resources in the semaphore will be greater than or equal to 0.
    </dd>

    <dt><strong><code>semaphore:give([given])</code></strong></dt>
    <dd>Gives resources to the semaphore. Parameter <code>given</code> is the number of resources
    given to the semaphore, if omitted it defaults to 1.
    If the total resources in the semaphore exceed the maximum, then it will be capped at the
    maximum. In that case the result will be <code>nil + "too many"</code>.
    </dd>

    <dt><strong><code>semaphore.new(max, [start], [timeout])</code></strong></dt>
    <dd>Creates and returns a new semaphore (fifo).
    <code>max</code> specifies the maximum number of resources the semaphore can hold.
    The optional <code>start</code> parameter (default 0) specifies the number of resources upon creation.
    The <code>timeout</code> specifies the default timeout for the lock in
    seconds, and defaults to 10.
    </dd>

    <dt><strong><code>semaphore:take([requested], [timeout])</code></strong></dt>
    <dd>Takes resources from the semaphore. Parameter <code>requested</code> is the number of resources
    requested from the semaphore, if omitted it defaults to 1.</br>
    If not enough resources are available it
    will yield and wait until enough resources are available, or a timeout occurs. The exception is when
    <code>timeout</code> is set to 0, in that case it will immediately return without yielding if there are
    not enough resources available.</br>
    The optional <code>timeout</code> parameter can be used to override the default timeout as set upon
    semaphore creation.
    Returns <code>true</code> upon success or <code>nil + "timeout"</code> on a timeout. In case more
    resources are requested than maximum available the error will be <code>"too many"</code>.
    </dd>

    <dt><strong><code>timer.new(options)</code></strong></dt>
    <dd>Creates and returns an (armed) timer object. The <code>options</code> table has the following fields;
    <ul>
        <li><code>options.recurring</code> boolean</li>
        <li><code>options.delay</code> expiry delay in seconds</li>
        <li><code>options.initial_delay</code> (optional) see <code>timer:arm()</code></li>
        <li><code>options.params</code> (optional) an opaque value that is passed to the callback upon expiry</li>
        <li><code>options.callback</code> is the function to execute on timer expiry.
            The callback function has <code>function(timer_obj, params)</code> as signature, where
            <code>params</code> is the value initially passed in <code>options.params</code></li>
    </ul>
    </dd>

    <dt><strong><code>timer:arm([initial_delay])</code></strong></dt>
    <dd>Arms a timer that was previously cancelled or exited. Returns the timer.
    The optional parameter <code>initial_delay</code>, determines the first delay.
    For example a recurring timer with <code>delay = 5</code>, and <code>initial_delay = 0</code> will
    execute immediately and then recur every 5 seconds.
    </dd>

    <dt><strong><code>timer:cancel()</code></strong></dt>
    <dd>Will cancel the timer.
    </dd>

</dl>

<h3>High level request functions</h3>

<p>The last ones are the higher level client functions to perform requests to (remote)
servers.</br>
</p>

<dl class="reference">
    <dt><strong><code>copas.http.request(url [, body])</code></strong> or</br>
        <strong><code>copas.http.request(requestparams)</code></strong></dt>
    <dd>Performs an http or https request, identical to the LuaSocket and LuaSec
    implementations, but wrapped in an async operation. As opposed to the original
    implementations, this one also allows for redirects cross scheme (http to https and
    viceversa).</br>
    </br>
    <strong>Note:</strong> https to http redirects are not allowed by
    default, but only when <code>requestparams.redirect == "all"</code>
    </dd>

    <dt><strong><code>copas.ftp.put(url, content)</code></strong> or</br>
        <strong><code>copas.ftp.put(requestparams)</code></strong></dt>
    <dd>Performs an ftp request, identical to the LuaSocket implementation, but wrapped in
    an async operation.
    </dd>

    <dt><strong><code>copas.ftp.get(url)</code></strong> or</br>
        <strong><code>copas.ftp.get(requestparams)</code></strong></dt>
    <dd>Performs an ftp request, identical to the LuaSocket implementation, but wrapped in
    an async operation.
    </dd>

    <dt><strong><code>copas.smtp.send(msgparams)</code></strong></dt>
    <dd>Sends an smtp request, identical to the LuaSocket implementation, but wrapped in
    an async operation.
    </dd>

    <dt><strong><code>copas.smtp.message(msgt)</code></strong></dt>
    <dd>Just points to <code>socket.smtp.message</code>, provided so the <code>copas.smtp</code>
    module is a drop-in replacement for the <code>socket.smtp</code> module
    </dd>

    <dt><strong><code>copas.limit.new(max)</code></strong></dt>
    <dd>Creates and returns a `limitset` that limits the concurrent tasks to <code>max</code> number
    of running tasks. Eg. 100 http requests, in a set with <code>max == 10</code>, then no more than
    10 requests will be performed simultaneously. Only when a request finishes, the next will be started.
    </dd>

    <dt><strong><code>limitset:addthread(func [, ...])</code></strong></dt>
    <dd>Identical to <code>copas.addthread</code>, except that it operates within the limits of
    the set of running tasks.
    </dd>

    <dt><strong><code>limitset:wait()</code></strong></dt>
    <dd>Will yield until all tasks in the set have finished.
    </dd>

</dl>

<h3>Low level Copas functions</h3>

<p>Most of these are wrapped in the socket wrapper functions, and wouldn't need
    to be used by user code on a regular basis.</p>

<dl class="reference">
    <dt><strong><code>copas.close(skt)</code></strong></dt>
    <dd>Closes the socket. Any read/write operations in progress will return
    with an error.
    </dd>

    <dt><strong><code>copas.connect(skt, address, port)</code></strong></dt>
    <dd>Connects and transforms a master socket to a client just like LuaSocket
    <code>socket:connect()</code>. The Copas version does not block and allows
    the multitasking of the other handlers and threads.
    </dd>

    <dt><strong><code>copas.dohandshake(skt, sslparams)</code></strong></dt>
    <dd>Performs an ssl handshake on an already connected TCP client socket. It
    returns the new ssl-socket on success, or throws an error on failure.
    </dd>

    <dt><strong><code>copas.flush(skt)</code></strong></br></dt>
    <dd>(deprecated)</dd>

    <dt><strong><code>copas.receive(skt [, pattern])</code></strong> (TCP) or</br>
    <strong><code>copas.receive(size)</code></strong> (UDP)
    </dt>
    <dd>Reads data from a client socket according to a pattern just like LuaSocket
    <code>socket:receive()</code>. The Copas version does not block and allows
    the multitasking of the other handlers and threads.</br>
    </br>
    <strong>Note:</strong> for UDP sockets the <code>size</code> parameter is NOT
    optional. For the wrapped function <code>socket:receive([size])</code> it is
    optional again.
    </dd>

    <dt><strong><code>copas.receivefrom(skt [, size])</code></strong></dt>
    <dd>Reads data from a UDP socket just like LuaSocket
    <code>socket:receivefrom()</code>. The Copas version does not block and allows
    the multitasking of the other handlers and threads.
    </dd>

    <dt><strong><code>copas.send(skt, data [, i [, j]])</code></strong> (TCP) or</br>
    <strong><code>copas.send(skt, datagram)</code></strong> (UDP)
    </dt>
    <dd>Sends data to a client socket just like <code>socket:send()</code>. The Copas version
    is buffered and does not block, allowing the multitasking of the other handlers and threads.</br>
    </br>
    Note: only for TCP, UDP send doesn't block, hence doesn't require this function to be used.
    </dd>

    <dt><strong><code>copas.sendto(skt, datagram, ip, port)</code></strong></dt>
    <dd>(deprecated, since UDP sending doesn't block)</dd>

    <dt><strong><code>copas.settimeout(skt, [timeout])</code></strong></dt>
    <dd>Sets the timeout (in seconds) for a socket. A negative timout or absent timeout (<code>nil</code>)
    will wait indefinitely.<br/>
    <strong>Important:</strong> this behaviour is the same as LuaSocket, but different from
    <code>copas.settimeouts</code>, where <code>nil</code> means 'do not change' the timeout.<br/>
    If a timeout is hit, the operation will return <code>nil + "timeout"</code>.
    Timeouts are applied on: <code>receive, receivefrom, receivePartial, send, connect, dohandshake</code>.</br>
    See <code>copas.useSocketTimeoutErrors()</code> below for alternative error messages.
    </dd>

    <dt><strong><code>copas.settimeouts(skt, [connect], [send], [receive])</code></strong></dt>
    <dd>Sets the timeouts (in seconds) for a socket. The default is to not have a timeout and wait
    indefinitely.<br/>
    <strong>Important:</strong> this behaviour is different from
    <code>copas.settimeout</code>, where <code>nil</code> means 'wait indefinitely'.<br/>
    If a timeout is hit, the operation will return <code>nil + "timeout"</code>.
    Timeouts are applied on: <code>receive, receivefrom, receivePartial, send, connect, dohandshake</code>.</br>
    See <code>copas.useSocketTimeoutErrors()</code> below for alternative error messages.
    </dd>

    <dt><strong><code>bool = copas.step([timeout])</code></strong></dt>
    <dd>Executes one copas iteration accepting client connections for the
    registered servers and handling those connections with the corresponding
    handlers. When a server accepts a connection, Copas calls the
    associated handler passing the client socket returned by
    <code>socket.accept()</code>. The <code>timeout</code> parameter is optional.
    It returns <code>false</code> when no data was handled (timeout) or
    <code>true</code> if there was data handled (or alternatively nil + error
    message in case of errors).</br>
    </br>
    <strong>NOTE:</strong> the <code>copas.running</code> flag will not automatically
    be (un)set. So when using your own main loop, consider manually setting the flag.
    </dd>

    <dt><strong><code>copas.timeout(delay, callback)</code></strong></dt>
    <dd>Creates a timeout timer for the current coroutine. The <code>delay</code>
    is the timeout in seconds, and the <code>callback</code> will
    be called upon an actual timeout occuring.</br>
    Calling it with <code>delay = 0</code> will cancel the timeout.</br>
    Calling it repeatedly will simply replace the timeout on the current
    coroutine and any previous callback set will no longer be called.</br>
    </br>
    <strong>NOTE:</strong> The timeouts are a low-level Copas feature, and
    should only be used to wrap an explicit yield to the Copas scheduler. They
    should not be used to wrap user code.</br>
    </br>
    For usage examples see the <code>lock</code> and <code>semaphore</code>
    implementations.
    </dd>

    <dt><strong><code>copas.useSocketTimeoutErrors([bool])</code></strong></dt>
    <dd>Sets the timeout errors to return for the current co-routine.
    The default is <code>false</code>, meaning
    that a timeout error will always return an error string <code>"timeout"</code>.
    If you are porting an existing application to Copas and want LuaSocket or LuaSec
    compatible error messages then set it to <code>true</code>.</br>
    </br>
    In case of using socket timeout errors, they can also be <code>"wantread"</code>
    or <code>"wantwrite"</code> when using ssl/tls connections. These can be returned at any point
    if during a read or write operation an ssl-renegotiation happens.</br>
    Due to platform difference the <code>connect</code> method may also return
    <code>"Operation already in progress"</code> as a timeout error message.
    </dd>

</dl>


</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0!</a></p>
	<p><small>$Id: reference.html,v 1.16 2009/04/07 21:34:52 carregal Exp $</small></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
